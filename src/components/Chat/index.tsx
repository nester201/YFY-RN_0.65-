import PropTypes from 'prop-types';
import React, { RefObject } from 'react';
import {
  Animated,
  Platform,
  StyleSheet,
  View,
  StyleProp,
  ViewStyle,
  SafeAreaView,
  FlatList,
  TextStyle,
  KeyboardAvoidingView,
  Text,
} from 'react-native';
import { v4 as uuidv4 } from 'uuid';
import { getBottomSpace } from 'react-native-iphone-x-helper';
import dayjs from 'dayjs';
import localizedFormat from 'dayjs/plugin/localizedFormat';

import InputToolbar from './InputToolbar';
import Message from './Message';
import MessageContainer from './MessageContainer';
import { IChatMessage } from '@interfaces/room';
import { IUser } from '@models/User';
import { colors } from '@theme';

dayjs.extend(localizedFormat);

interface IChat {
  messages?: IChatMessage[];
  isTyping?: boolean;
  /* Input text; default is undefined, but if specified, it will override GiftedChat's internal state */
  text?: string;
  /* enables the scrollToBottom Component */
  scrollToBottom?: boolean;
  /* Scroll to bottom wrapper style */
  scrollToBottomStyle?: StyleProp<ViewStyle>;
  initialText?: string;
  /* Makes the composer not editable*/
  disableComposer?: boolean;
  /* User sending the messages: { id, name, avatar } */
  user?: IUser;
  /*  Locale to localize the dates */
  locale?: string;
  /* Render the message avatar at the top of consecutive messages, rather than the bottom; default is false */
  isKeyboardInternallyHandled?: boolean;
  /*Distance of the chat from the bottom of the screen (e.g. useful if you display a tab bar) */
  bottomOffset?: number;
  /* Minimum height of the input toolbar; default is 44 */
  minInputToolbarHeight?: number;
  /*Determines whether the keyboard should stay visible after a tap; see <ScrollView> docs */
  keyboardShouldPersistTaps?: any;
  /*Max message composer TextInput length */
  maxInputLength?: number;
  /* Force getting keyboard height to fix some display issues */
  forceGetKeyboardHeight?: boolean;
  /* This can be used to pass any data which needs to be re-rendered */
  extraData?: any;
  /* composer min Height */
  minComposerHeight?: number;
  /* composer min Height */
  maxComposerHeight?: number;
  options?: { [key: string]: any };
  /* Callback when a message avatar is tapped */
  onPressAvatar?(user: IUser): void;
  /* Callback when a message avatar is tapped */
  onLongPressAvatar?(user: IUser): void;
  /* Generate an id for new messages. Defaults to UUID v4, generated by uuid */
  messageIdGenerator?(message?: IChatMessage): string;
  /* Callback when sending a message */
  onSend?(messages: IChatMessage[]): void;
  /* Callback when a message bubble is long-pressed; default is to show an ActionSheet with "Copy Text" (see example using showActionSheetWithOptions()) */
  onLongPress?(context: any, message: any): void;
  /* Callback when the input text changes */
  onInputTextChanged?(text: string): void;
  /* Custom parse patterns for react-native-parsed-text used to linking message content (like URLs and phone numbers) */
  parsePatterns?(linkStyle: TextStyle): any;
  /* Scroll to bottom custom component */
  scrollToBottomComponent?(): React.ReactNode;
  shouldUpdateMessage?(props: Message['props'], nextProps: Message['props']): boolean;
}

interface State {
  isInitialized: boolean;
  composerHeight?: number;
  messagesContainerHeight?: number | Animated.Value;
  typingDisabled: boolean;
  text?: string;
  messages?: IChatMessage[];
}

export default class Chat extends React.Component<IChat, State> {
  static childContextTypes = {
    getLocale: PropTypes.func,
  };

  static defaultProps = {
    messages: [],
    text: undefined,
    disableComposer: false,
    messageIdGenerator: () => uuidv4(),
    user: {},
    onSend: () => undefined,
    locale: null,
    loadEarlier: false,
    isLoadingEarlier: false,
    renderLoading: null,
    renderLoadEarlier: null,
    renderAvatar: undefined,
    showUserAvatar: false,
    onPressAvatar: null,
    onLongPressAvatar: null,
    onLongPress: null,
    isKeyboardInternallyHandled: true,
    bottomOffset: null,
    minInputToolbarHeight: 60,
    keyboardShouldPersistTaps: Platform.select({
      ios: 'never',
      android: 'always',
      default: 'never',
    }),
    onInputTextChanged: null,
    maxInputLength: null,
    forceGetKeyboardHeight: false,
    extraData: null,
    minComposerHeight: 60,
    maxComposerHeight: 60,
  };

  _isMounted = false;
  _keyboardHeight = 0;
  _bottomOffset = 0;
  _maxHeight?: number = undefined;
  _isFirstLayout = true;
  _locale = 'en';
  invertibleScrollViewProps: any = undefined;
  _messageContainerRef?: RefObject<FlatList<IChatMessage>> = React.createRef();
  _isTextInputWasFocused = false;
  textInput?: any;

  state = {
    isInitialized: false, // initialization will calculate maxHeight before rendering the chat
    composerHeight: this.props.minComposerHeight,
    messagesContainerHeight: undefined,
    typingDisabled: false,
    text: undefined,
    messages: undefined,
  };

  constructor(props: IChat) {
    super(props);

    this.invertibleScrollViewProps = {
      keyboardShouldPersistTaps: this.props.keyboardShouldPersistTaps,
      onKeyboardWillShow: this.onKeyboardWillShow,
      onKeyboardWillHide: this.onKeyboardWillHide,
      onKeyboardDidShow: this.onKeyboardDidShow,
      onKeyboardDidHide: this.onKeyboardDidHide,
    };
  }

  getChildContext() {
    return {
      getLocale: this.getLocale,
    };
  }

  componentDidMount() {
    const { messages, text } = this.props;
    this.setIsMounted(true);
    this.initLocale();
    this.setMessages(messages || []);
    this.setTextFromProp(text);
  }

  componentWillUnmount() {
    this.setIsMounted(false);
  }

  componentDidUpdate(prevProps: IChat = {}) {
    const { messages, text } = this.props;

    if (this.props !== prevProps) {
      this.setMessages(messages || []);
    }

    if (text !== prevProps.text) {
      this.setTextFromProp(text);
    }
  }

  initLocale() {
    if (this.props.locale === null) {
      this.setLocale('en');
    } else {
      this.setLocale(this.props.locale || 'en');
    }
  }

  setLocale(locale: string) {
    this._locale = locale;
  }

  getLocale = () => this._locale;

  setTextFromProp(textProp?: string) {
    // Text prop takes precedence over state.
    if (textProp !== undefined && textProp !== this.state.text) {
      this.setState({ text: textProp });
    }
  }

  getTextFromProp(fallback: string) {
    if (this.props.text === undefined) {
      return fallback;
    }
    return this.props.text;
  }

  setMessages(messages: IChatMessage[]) {
    this.setState({ messages });
  }

  getMessages() {
    return this.state.messages;
  }

  setMaxHeight(height: number) {
    this._maxHeight = height;
  }

  getMaxHeight() {
    return this._maxHeight;
  }

  setKeyboardHeight(height: number) {
    this._keyboardHeight = height;
  }

  getKeyboardHeight() {
    if (Platform.OS === 'android' && !this.props.forceGetKeyboardHeight) {
      // For android: on-screen keyboard resized main container and has own height.
      // @see https://developer.android.com/training/keyboard-input/visibility.html
      // So for calculate the messages container height ignore keyboard height.
      return 0;
    }
    return this._keyboardHeight;
  }

  setBottomOffset(value: number) {
    this._bottomOffset = value;
  }

  getBottomOffset() {
    return this._bottomOffset;
  }

  setIsFirstLayout(value: boolean) {
    this._isFirstLayout = value;
  }

  getIsFirstLayout() {
    return this._isFirstLayout;
  }

  setIsTypingDisabled(value: boolean) {
    this.setState({
      typingDisabled: value,
    });
  }

  getIsTypingDisabled() {
    return this.state.typingDisabled;
  }

  setIsMounted(value: boolean) {
    this._isMounted = value;
  }

  getIsMounted() {
    return this._isMounted;
  }

  getMinInputToolbarHeight() {
    return this.props.minInputToolbarHeight;
  }

  calculateInputToolbarHeight(composerHeight: number) {
    return composerHeight + (this.getMinInputToolbarHeight()! - this.props.minComposerHeight!);
  }

  /**
   * Returns the height, based on current window size, without taking the keyboard into account.
   */
  getBasicMessagesContainerHeight(composerHeight = this.state.composerHeight) {
    return this.getMaxHeight()! - this.calculateInputToolbarHeight(composerHeight!);
  }

  /**
   * Returns the height, based on current window size, taking the keyboard into account.
   */
  getMessagesContainerHeightWithKeyboard(composerHeight = this.state.composerHeight) {
    return this.getBasicMessagesContainerHeight(composerHeight) - this.getKeyboardHeight() + this.getBottomOffset();
  }

  safeAreaSupport = (bottomOffset?: number) => {
    return bottomOffset != null ? bottomOffset : getBottomSpace();
  };

  /**
   * Store text input focus status when keyboard hide to retrieve
   * it after wards if needed.
   * `onKeyboardWillHide` may be called twice in sequence so we
   * make a guard condition (eg. showing image picker)
   */
  handleTextInputFocusWhenKeyboardHide() {
    if (!this._isTextInputWasFocused) {
      this._isTextInputWasFocused = this.textInput?.isFocused() || false;
    }
  }

  /**
   * Refocus the text input only if it was focused before showing keyboard.
   * This is needed in some cases (eg. showing image picker).
   */
  handleTextInputFocusWhenKeyboardShow() {
    if (this.textInput && this._isTextInputWasFocused && !this.textInput.isFocused()) {
      this.textInput.focus();
    }

    // Reset the indicator since the keyboard is shown
    this._isTextInputWasFocused = false;
  }

  onKeyboardWillShow = (e: any) => {
    this.handleTextInputFocusWhenKeyboardShow();

    if (this.props.isKeyboardInternallyHandled) {
      this.setIsTypingDisabled(true);
      this.setKeyboardHeight(e.endCoordinates ? e.endCoordinates.height : e.end.height);
      this.setBottomOffset(this.safeAreaSupport(this.props.bottomOffset));
      const newMessagesContainerHeight = this.getMessagesContainerHeightWithKeyboard();
      this.setState({
        messagesContainerHeight: newMessagesContainerHeight,
      });
    }
  };

  onKeyboardWillHide = (_e: any) => {
    this.handleTextInputFocusWhenKeyboardHide();

    if (this.props.isKeyboardInternallyHandled) {
      this.setIsTypingDisabled(true);
      this.setKeyboardHeight(0);
      this.setBottomOffset(0);
      const newMessagesContainerHeight = this.getBasicMessagesContainerHeight();
      this.setState({
        messagesContainerHeight: newMessagesContainerHeight,
      });
    }
  };

  onKeyboardDidShow = (e: any) => {
    if (Platform.OS === 'android') {
      this.onKeyboardWillShow(e);
    }
    this.setIsTypingDisabled(false);
  };

  onKeyboardDidHide = (e: any) => {
    if (Platform.OS === 'android') {
      this.onKeyboardWillHide(e);
    }
    this.setIsTypingDisabled(false);
  };

  scrollToBottom(animated = true) {
    if (this._messageContainerRef && this._messageContainerRef.current) {
      this._messageContainerRef.current.scrollToOffset({
        offset: 0,
        animated,
      });
    }
  }

  renderMessages() {
    const { ...messagesContainerProps } = this.props;
    const fragment = (
      <View
        style={{
          paddingHorizontal: 16,
          backgroundColor: colors.secondaryContainerBackground,
          height: this.state.messagesContainerHeight,
        }}
      >
        <MessageContainer
          {...messagesContainerProps}
          messages={this.getMessages()}
          forwardRef={this._messageContainerRef}
          isTyping={this.props.isTyping}
        />
      </View>
    );

    return this.props.isKeyboardInternallyHandled ? (
      <KeyboardAvoidingView enabled>{fragment}</KeyboardAvoidingView>
    ) : (
      fragment
    );
  }

  onSend = (messages: IChatMessage[] = []) => {
    if (!Array.isArray(messages)) {
      messages = [messages];
    }
    const newMessages: IChatMessage[] = messages.map(message => {
      return {
        ...message,
        user: this.props.user!,
        createdAt: new Date(),
        id: this.props.messageIdGenerator && this.props.messageIdGenerator(),
      } as IChatMessage;
    });

    this.setIsTypingDisabled(true);
    this.resetInputToolbar();

    if (this.props.onSend) {
      this.props.onSend(newMessages);
    }

    setTimeout(() => {
      if (this.getIsMounted()) {
        this.setIsTypingDisabled(false);
      }
    }, 100);
  };

  resetInputToolbar() {
    if (this.textInput) {
      this.textInput.clear();
    }
    this.notifyInputTextReset();
    const newComposerHeight = this.props.minComposerHeight;
    const newMessagesContainerHeight = this.getMessagesContainerHeightWithKeyboard(newComposerHeight);
    this.setState({
      text: this.getTextFromProp(''),
      composerHeight: newComposerHeight,
      messagesContainerHeight: newMessagesContainerHeight,
    });
  }

  focusTextInput() {
    if (this.textInput) {
      this.textInput.focus();
    }
  }

  onInputSizeChanged = (size: { height: number }) => {
    const newComposerHeight = Math.max(
      this.props.minComposerHeight!,
      Math.min(this.props.maxComposerHeight!, size.height)
    );
    const newMessagesContainerHeight = this.getMessagesContainerHeightWithKeyboard(newComposerHeight);
    this.setState({
      composerHeight: newComposerHeight,
      messagesContainerHeight: newMessagesContainerHeight,
    });
  };

  onInputTextChanged = (text: string) => {
    if (this.getIsTypingDisabled()) {
      return;
    }
    if (this.props.onInputTextChanged) {
      this.props.onInputTextChanged(text);
    }
    // Only set state if it's not being overridden by a prop.
    if (this.props.text === undefined) {
      this.setState({ text });
    }
  };

  notifyInputTextReset() {
    if (this.props.onInputTextChanged) {
      this.props.onInputTextChanged('');
    }
  }

  onInitialLayoutViewLayout = (e: any) => {
    const { layout } = e.nativeEvent;
    if (layout.height <= 0) {
      return;
    }
    this.notifyInputTextReset();
    this.setMaxHeight(layout.height);
    const newComposerHeight = this.props.minComposerHeight;
    const newMessagesContainerHeight = this.getMessagesContainerHeightWithKeyboard(newComposerHeight);
    const initialText = this.props.initialText || '';
    this.setState({
      isInitialized: true,
      text: this.getTextFromProp(initialText),
      composerHeight: newComposerHeight,
      messagesContainerHeight: newMessagesContainerHeight,
    });
  };

  onMainViewLayout = (e: any) => {
    // fix an issue when keyboard is dismissing during the initialization
    const { layout } = e.nativeEvent;
    if (this.getMaxHeight() !== layout.height || this.getIsFirstLayout()) {
      this.setMaxHeight(layout.height);
      this.setState({
        messagesContainerHeight:
          this._keyboardHeight > 0
            ? this.getMessagesContainerHeightWithKeyboard()
            : this.getBasicMessagesContainerHeight(),
      });
    }
    if (this.getIsFirstLayout()) {
      this.setIsFirstLayout(false);
    }
  };

  renderInputToolbar() {
    const inputToolbarProps = {
      ...this.props,
      text: this.getTextFromProp(this.state.text!),
      composerHeight: Math.max(this.props.minComposerHeight!, this.state.composerHeight!),
      onSend: this.onSend,
      onInputSizeChanged: this.onInputSizeChanged,
      onTextChanged: this.onInputTextChanged,
      textInputProps: {
        ref: (textInput: any) => (this.textInput = textInput),
        maxLength: this.getIsTypingDisabled() ? 0 : this.props.maxInputLength,
      },
    };

    return <InputToolbar {...inputToolbarProps} />;
  }

  renderLoading() {
    return <Text>Loading</Text>;
  }

  render() {
    if (this.state.isInitialized) {
      return (
        <SafeAreaView style={styles.safeArea}>
          <View style={styles.container} onLayout={this.onMainViewLayout}>
            {this.renderMessages()}
            {this.renderInputToolbar()}
          </View>
        </SafeAreaView>
      );
    }
    return (
      <View style={styles.container} onLayout={this.onInitialLayoutViewLayout}>
        {this.renderLoading()}
      </View>
    );
  }
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  safeArea: {
    flex: 1,
  },
});
